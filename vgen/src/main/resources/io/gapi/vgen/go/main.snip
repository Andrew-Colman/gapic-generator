@extends "common.snip"

@snippet generateFilename(service)
    {@context.upperCamelToLowerUnderscore(context.getVeneerName(service))}.go
@end

@snippet generateClass(service, body)
    {@headerComment(editingInstruction(service))}

    package {@context.getPackageName}

    {@importSection(service)}

    {@body}
@end

@private editingInstruction(service)
    // EDITING INSTRUCTIONS
    // This file was generated from the file
    // https://github.com/googleapis/blob/master/{@service.getFile().getSimpleName()}
    // and updates to that file get reflected here through a refresh process.
    // For the short term, the refresh process will only be runnable by Google engineers.
    // Manual additions are allowed because the refresh process performs
    // a 3-way merge in order to preserve those manual additions. In order to not
    // break the refresh process, only certain types of modifications are
    // allowed.
    //
@end

@private importSection(service)
    import (
    	@join import : context.getImports(service)
    	{@import}
    	@end
    )
@end

@snippet generateBody(service)
    // AUTO-GENERATED DOCUMENTATION AND SERVICE -- see instructions at the top of the file for editing.

    @join commentLine : context.comments(service)
        {@commentLine}
    @end
    {@manualEdit()}
    type {@context.getVeneerName(service)} struct {
    	// The connection to the service.
    	conn *grpc.ClientConn

    	// The gRPC API client.
    	client {@context.getServiceClientName(service)}

    	// The map from the method name to the default call options for the method of this service.
    	CallOptions map[string][]gax.CallOption
    }

    {@globals(service)}

    {@constructor(service)}
    {@pathTemplateMethods(service)}
    {@methods(service)}

    {@iterators(service)}
@end

@private globals(service)
    var (
    	allScopes{@context.getVeneerName(service)} = []string {
    		@join scope : context.getServiceConfig.getAuthScopes(service)
    			"{@scope}",
    		@end
    	}
    	@join retryDef : context.entrySet(context.getApiConfig.getInterfaceConfig(service).getRetryParamsDefinition)
    	{@retryDef.getKey}_{@context.getVeneerName(service)}RetryParams = []gax.CallOption {
    		gax.WithRetryInterval({@retryDef.getValue.getRetryBackoff.getInitialDelayMillis}*time.Millisecond),
    		gax.WithIntervalMultiplier({@retryDef.getValue.getRetryBackoff.getDelayMultiplier}),
    		gax.WithMaxInterval({@retryDef.getValue.getRetryBackoff.getMaxDelayMillis}*time.Millisecond),
    		gax.WithTimeout({@retryDef.getValue.getTimeoutBackoff.getInitialDelayMillis}*time.Millisecond),
    		gax.WithTimeoutMultiplier({@retryDef.getValue.getTimeoutBackoff.getDelayMultiplier}),
    		gax.WithMaxTimeout({@retryDef.getValue.getTimeoutBackoff.getMaxDelayMillis}*time.Millisecond),
    	}
    	@end
    )

    var (
    	@join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
    	{@pathTemplateVarName(service, collectionConfig)} = gax.MustCompilePathTemplate("{@collectionConfig.getNamePattern}")
    	@end
    )
@end

@private constructor(service)
    // New{@context.getVeneerName(service)} creates a new API service client.
    func New{@context.getVeneerName(service)}(ctx context.Context, opts ...cloud.ClientOption) (*{@context.getVeneerName(service)}, error) {
    	o := []cloud.ClientOption {
    		cloud.WithEndpoint(prodAddr),
    		cloud.WithScopes(allScopes{@context.getVeneerName(service)}...),
    		cloud.WithUserAgent(clientUserAgent),
    	}
    	o = append(o, opts...)
    	conn, err := transport.DialGRPC(ctx, o...)
    	if err != nil {
    		return nil, err
    	}
    	return &{@context.getVeneerName(service)} {
    		conn: conn,
    		client: {@context.getServiceClientConstructorName(service)}(conn),
    		CallOptions: map[string][]gax.CallOption{
    			@join method : service.getMethods
      			"{@method.getSimpleName}": {@context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method).getRetryParamsConfigName}_{@context.getVeneerName(service)}RetryParams,
    			@end
    		},
    	}, nil
    }

    // Close closes the connection to the API service. The user should invoke this when
    // it's not used anymore. Typically the user code would look like:
    //    api := New{@context.getVeneerName(service)}(ctx)
    //    defer api.Close()
    //    // Calling api methods...
    func (api *{@context.getVeneerName(service)}) Close() {
    	api.conn.Close()
    }
@end

@private pathTemplateVarName(service, collectionConfig)
    {@context.lowerUnderscoreToLowerCamel(collectionConfig.getMethodBaseName)}{@context.getVeneerName(service)}PathTemplate
@end

@private createResourceFunctionParams(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on ", "
        {@context.lowerUnderscoreToLowerCamel(param)} string
    @end
@end

@private extractResourceFunctionReturnType(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on ", "
        string
    @end
@end

@private extractResourceFunctionErrorReturns(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on ", "
        ""
    @end
@end

@private extractResourceFunctionSuccessfulReturns(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on ", "
        binding["{@param}"]
    @end
@end

@private createResourceDocParams(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on " and "
        the {@param}
    @end
@end

# PathTemplates are currently methods of the service. They don't have to be, but
# this would be good to shorten the method names, and normally the users of these
# methods would have the service instance already.
@private pathTemplateMethods(service)
    @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
      @let methodBase = context.lowerUnderscoreToUpperCamel(collectionConfig.getMethodBaseName)

        // Create{@methodBase}Path creates the {@collectionConfig.getMethodBaseName} path "{@collectionConfig.getNamePattern}" with {@createResourceDocParams(collectionConfig)}.
        func (api *{@context.getVeneerName(service)}) Create{@methodBase}Path({@createResourceFunctionParams(collectionConfig)}) (string, error) {
        	return {@pathTemplateVarName(service, collectionConfig)}.Instantiate(map[string]string{
        		@join param : collectionConfig.getNameTemplate.vars()
        		"{@param}": {@context.lowerUnderscoreToLowerCamel(param)},
        		@end
        	})
        }

        // ExtractFrom{@methodBase}Path returns {@createResourceDocParams(collectionConfig)} from the path by matching with the template "{@collectionConfig.getNamePattern}".
        func (api *{@context.getVeneerName(service)}) ExtractFrom{@methodBase}Path(path string) ({@extractResourceFunctionReturnType(collectionConfig)}, error) {
        	binding, err := {@pathTemplateVarName(service, collectionConfig)}.Match(path)
        	if err != nil {
        		return {@extractResourceFunctionErrorReturns(collectionConfig)}, err
        	}
        	return {@extractResourceFunctionSuccessfulReturns(collectionConfig)}, nil
        }
      @end
    @end
@end

@private methods(service)
    @join method : service.getMethods
        @let methodName = method.getSimpleName, \
             lowerMethodName = context.upperCamelToLowerCamel(methodName), \
             inTypeName = context.typeName(method.getInputType), \
             outTypeName = context.typeName(method.getOutputType), \
             methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             isPageStreaming = methodConfig.isPageStreaming, \
             isFlattening = methodConfig.isFlattening
            @if {@isPageStreaming}
                @let pageStreaming = methodConfig.getPageStreaming(), \
                     iteratorTypeName = context.getIteratorTypeName(pageStreaming), \
                     iteratorPageTypeName = context.getIteratorPageTypeName(pageStreaming), \
                     resourceFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getResourcesField().getSimpleName), \
                     requestTokenFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getRequestTokenField().getSimpleName), \
                     responseTokenFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getResponseTokenField().getSimpleName), \
                     tokenType = context.getNextPageTokenType(service, pageStreaming), \
                     tokenZeroValue = context.zeroValue(pageStreaming.getRequestTokenField().getType)

                    {@methodComment(method)}
                    func (api *{@context.getVeneerName(service)}) {@methodName}(ctx context.Context, req {@inTypeName}, opts ...gax.CallOption) (*{@iteratorTypeName}, error) {
                    	opts = append(api.CallOptions["{@methodName}"], opts...)
                    	@if {@method.getResponseStreaming}
                    	result, err := gax.Invoke(ctx, req, api.{@lowerMethodName}, opts...)
                    	if err != nil {
                    		return nil, err
                    	}
                    	receiver := result.({@context.getStreamReceiver(service, method)})
                    	return &{@iteratorTypeName}{
                    		apiCall: func() ({@iteratorPageTypeName}, error) {
                    			resp, err := receiver.Recv()
                    			if err != nil {
                    				return {@iteratorPageTypeName}{}, err
                    			}
                    			return {@iteratorPageTypeName}{
                    				Items: resp.{@resourceFieldName},
                    				NextPageToken: resp.{@responseTokenFieldName},
                    			}, nil
                    		},
                    	}, nil
                    	@else
                    	atLastPage := false
                    	return &{@iteratorTypeName}{
                    		apiCall: func() ({@iteratorPageTypeName}, error) {
                    			if atLastPage {
                    				return {@iteratorPageTypeName}{}, io.EOF
                    			}
                    			result, err := gax.Invoke(ctx, req, api.{@lowerMethodName}, opts...)
                    			if err != nil {
                    				return {@iteratorPageTypeName}{}, err
                    			}
                    			resp := result.({@outTypeName})
                    			if resp.{@responseTokenFieldName} == {@tokenZeroValue} {
                    				atLastPage = true
                    			} else {
                    				req.{@requestTokenFieldName} = resp.{@responseTokenFieldName}
                    			}
                    			return {@iteratorPageTypeName}{
                    				Items: resp.{@resourceFieldName},
                    				NextPageToken: resp.{@responseTokenFieldName},
                    			}, nil
                    		},
                    	}, nil
                    	@end
                    }

                    @if {@isFlattening}
                        @let fields = context.getFlatteningFields(methodConfig)
                            {@flattenedMethodComment(method, fields)}
                            func (api *{@context.getVeneerName(service)}) {@methodName}With(ctx context.Context, {@flattenedParameters(fields)} opts ...gax.CallOption) (*{@iteratorTypeName}, error) {
                            	return api.{@methodName}(ctx, {@context.constructionExpr(method.getInputType)}{
                            		@join field : fields
                             		{@context.lowerUnderscoreToUpperCamel(field.getSimpleName)}: {@context.lowerUnderscoreToLowerCamel(field.getSimpleName)},
                            		@end
                            	}, opts...)
                            }

                        @end
                    @end
                @end
            @else

                {@methodComment(method)}
                func (api *{@context.getVeneerName(service)}) {@methodName}(ctx context.Context, req {@inTypeName}, opts ...gax.CallOption) ({@outTypeName}, error) {
                	opts = append(api.CallOptions["{@methodName}"], opts...)
                	resp, err := gax.Invoke(ctx, req, api.{@lowerMethodName}, opts...)
                	if err != nil {
                		return nil, err
                	}
                        return resp.({@outTypeName}), nil
                }

                @if {@isFlattening}
                    @let fields = context.getFlatteningFields(methodConfig)
                        {@flattenedMethodComment(method, fields)}
                        func (api *{@context.getVeneerName(service)}) {@methodName}With(ctx context.Context, {@flattenedParameters(fields)} opts ...gax.CallOption) ({@outTypeName}, error) {
                        	return api.{@methodName}(ctx, {@context.constructionExpr(method.getInputType)}{
                        		@join field : fields
                         		{@context.lowerUnderscoreToUpperCamel(field.getSimpleName)}: {@context.lowerUnderscoreToLowerCamel(field.getSimpleName)},
                        		@end
                        	}, opts...)
                        }

                    @end
                @end
            @end

            // {@lowerMethodName} is a gax.APICall that calls api.client.{@methodName}.
            func (api *{@context.getVeneerName(service)}) {@lowerMethodName}(ctx context.Context, req interface{}) (interface{}, error) {
            	return api.client.{@methodName}(ctx, req.({@inTypeName}))
            }
        @end
    @end
@end

@private methodComment(method)
    // AUTO-GENERATED DOCUMENTATION AND METHOD -- see instructions at the top of the file for editing.

    @join commentLine : context.comments(method)
        {@commentLine}
    @end
    {@manualEdit()}
@end

@private manualEdit()
    //
    //
@end

@private flattenedMethodComment(method, fields)
    // AUTO-GENERATED DOCUMENTATION AND METHOD -- see instructions at the top of the file for editing.

    @join commentLine : context.comments(method)
        {@commentLine}
    @end
    //
    @join field : fields vertical
        @join commentLine : context.getFieldComments(field)
            {@commentLine}
        @end
    @end
    {@manualEdit()}
@end

@private flattenedParameters(fields)
    @join field : fields on " "
        {@context.lowerUnderscoreToLowerCamel(field.getSimpleName)} {@context.typeName(field.getType)},
    @end
@end

@private flattenedBuilder(fields)
@end

@private iterators(service)
    // Iterators.
    //
    @join pageStreaming : context.getPageStreamingConfigs(service)
        @let iteratorTypeName = context.getIteratorTypeName(pageStreaming), \
             iteratorPageTypeName = context.getIteratorPageTypeName(pageStreaming), \
             tokenType = context.getNextPageTokenType(service, pageStreaming), \
             resourceFieldType = context.getResourceTypeName(pageStreaming.getResourcesField())

            // {@iteratorPageTypeName} represents a page in a stream of {@iteratorTypeName}.
            // This will be updated through {@iteratorTypeName}.Advance.
            type {@iteratorPageTypeName} struct {
            	// The elements in the current page.
            	Items []{@resourceFieldType}

            	// The token to get the next page response. This can be used to resume the iteration.
            	NextPageToken {@tokenType}
            }

            // {@iteratorTypeName} manages a stream of {@resourceFieldType}.
            type {@iteratorTypeName} struct {
            	// The current page data.
            	Page         {@iteratorPageTypeName}
            	currentIndex int
            	apiCall      func() ({@iteratorPageTypeName}, error)
            }

            // Advance moves to the next page and updates its internal data.
            // This returns io.EOF if no more pages exist.
            func (iterator *{@iteratorTypeName}) Advance() error {
            	page, err := iterator.apiCall()
            	if err == nil {
            		iterator.Page = page
            	}
            	return err
            }

            // Next returns the next element in the stream. This returns io.EOF at the end of
            // the stream.
            func (iterator *{@iteratorTypeName}) Next() ({@resourceFieldType}, error) {
            	for iterator.currentIndex >= len(iterator.Page.Items) {
            		err := iterator.Advance()
            		if err != nil {
            			return nil, err
            		}
            		iterator.currentIndex = 0
            	}
            	result := iterator.Page.Items[iterator.currentIndex]
            	iterator.currentIndex++
            	return result, nil
            }
        @end
    @end
@end

@private iterator(iteratorTypeName, resourceFieldType)
@end
