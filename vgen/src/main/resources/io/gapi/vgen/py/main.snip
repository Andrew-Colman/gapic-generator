@snippet generateFilename(service)
    {@context.upperCamelToLowerUnderscore(context.getVeneerName(service))}.py
@end

@snippet generateClass(service, body, imports)
    {@licenseSection(service)}

    {@importSection(imports)}


    {@body}
@end

@snippet generateBody(service)
    {@serviceClass(service)}
@end

@private licenseSection(service)
    @# Copyright 2016 Google Inc. All rights reserved.
    @#
    @# Licensed under the Apache License, Version 2.0 (the "License");
    @# you may not use this file except in compliance with the License.
    @# You may obtain a copy of the License at
    @#
    @# http://www.apache.org/licenses/LICENSE-2.0
    @#
    @# Unless required by applicable law or agreed to in writing, software
    @# distributed under the License is distributed on an "AS IS" BASIS,
    @# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    @# See the License for the specific language governing permissions and
    @# limitations under the License.
    @#
    @# EDITING INSTRUCTIONS
    @# This file was generated from the file
    @# https://github.com/google/googleapis/blob/master/{@context.getRelativeProtoPath(service)},
    @# and updates to that file get reflected here through a refresh process.
    @# For the short term, the refresh process will only be runnable by Google engineers.
    @#
    @# The only allowed edits are to method and file documentation. A 3-way
    @# merge preserves those additions if the generated source changes.
@end

@private importSection(imports)
    @join import : imports
        {@import}
    @end
@end

@private serviceClass(service)
    @let path_templates = {@pathTemplateSection(service)}, \
         documentation = {@comments(service)}
        class {@context.getVeneerName(service)}(object):
            @if documentation
                {@documentation}

            @end
            {@constantSection(service)}

            @if path_templates
                {@path_templates}

            @end
            {@initMethodSection(service)}

            {@genericMethodsSection()}

            {@serviceMethodsSection(service)}

    @end
@end

@private constantSection(service)
    SERVICE_ADDRESS = '{@context.getServiceConfig.getServiceAddress(service)}'
    """The default address of the service."""

    DEFAULT_SERVICE_PORT = {@context.getServiceConfig.getServicePort()}
    """The default port of the service."""

    @# The scopes needed to make gRPC calls to all of the methods defined in
    @# this service
    _ALL_SCOPES = (
        @join auth_scope : context.getServiceConfig.getAuthScopes(service) on BREAK
            '{@auth_scope}',
        @end
    )
@end

@private methodConfigDict(service)
    @join method : service.getMethods
        method: MethodConfig(
    @end
@end

@private initMethodSection(service)
    @let stubModule = pyproto.getPbFileName(service), \
             stubService = service.getSimpleName()
        def __init__(
                self,
                service_path=SERVICE_ADDRESS,
                port=DEFAULT_SERVICE_PORT,
                channel=None,
                ssl_creds=None,
                scopes=_ALL_SCOPES,
                is_idempotent_retrying=True,
                max_attempts=3,
                timeout=30):
            """Constructor.

            Args:
              :keyword service_path: The DNS of the API remote host.
              :type service_path: string
              :keyword port: The port on which to connect to the remote host.
              :type port: int
              :keyword channel: A Channel object through which to make calls.
              :type channel: A grpc.beta.implementations.Channel object
              :keyword ssl_creds: A ClientCredentials for use with an SSL-
                enabled channel
              :type ssl_creds: A grpc.beta.implementations.ClientCredentials
                object
              :keyword is_idempotent_retrying: If set, idempotent RPCs sent
                through this client will retry upon transient failure by
                default.
              :type is_idempotent_retrying: bool
              :keyword max_attempts: The maximum number of times to retry a
                method that is configured to retry upon transient failure
              :type max_attempts: int
              :keyword timeout: The default timeout, in seconds, for calls made
                through this client
              :type timeout: int
            """
            self._defaults = dict()
            {@defaultsSection(service)}

            self.stub = config.create_stub(
                {@stubModule}.beta_create_{@stubService}_stub,
                service_path,
                port,
                ssl_creds=ssl_creds,
                channel=channel,
                scopes=scopes)
    @end
@end

@private defaultsSection(service)
    @join method : service.getMethods
        @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             methodName = context.upperCamelToLowerUnderscore(method.getSimpleName), \
             isPageStreaming = methodConfig.isPageStreaming(), \
             isBundling = methodConfig.isBundling()
            self._defaults['{@methodName}'] = CallSettings(
                timeout=timeout,
                @if context.isIdempotent(method)
                    is_retrying=is_idempotent_retrying,
                @end
                max_attempts=max_attempts,
                @if isPageStreaming
                    @let pageStreaming = methodConfig.getPageStreaming(), \
                            requestToken = pageStreaming.getRequestTokenField().getSimpleName(), \
                            responseToken = pageStreaming.getResponseTokenField().getSimpleName(), \
                            resources = pageStreaming.getResourcesField().getSimpleName()
                        page_descriptor=PageDescriptor(
                            '{@requestToken}',
                            '{@responseToken}',
                            '{@resources}',
                        ),
                    @end
                @end
                @if isBundling
                    @let bundling = methodConfig.getBundling(), \
                            count = bundling.getElementCountThreshold(), \
                            bytes = bundling.getRequestByteThreshold(), \
                            delay = bundling.getDelayThresholdMillis()
                        bundler=bundling.Executor(BundleOptions(
                            @if count
                                element_count_threshold={@count},
                            @end
                            @if bytes
                                request_bytesize_threshold={@bytes},
                            @end
                            @if delay
                                delay_threshold={@delay}
                            @end
                        )
                        bundle_descriptor=BundleDescriptor(
                            {@bundleDescriptorBody(bundling, method)}
                        ),
                    @end
                @end
            )
        @end
    @end
@end

@private bundleDescriptorBody(bundling, method)
    @let bundledField = bundling.getBundledField().getSimpleName(), \
            discriminatorFields = bundling.getDiscriminatorFields()
        @if {@bundling.hasSubresponseField}
                '{@bundledField}',
                  [
                      @join fieldSelector : bundling.getDiscriminatorFields() on {@", "}.add(BREAK)
                          '{@fieldSelector.getParamName}'
                      @end
                  ],
                'subresponse_field={@bundling.getSubresponseField().getSimpleName()}',
        @else
                '{@bundledField}',
                  [
                      @join fieldSelector : bundling.getDiscriminatorFields() on {@", "}.add(BREAK)
                          '{@fieldSelector.getParamName}'
                      @end
                  ]
        @end
    @end
@end

@private pathTemplateName(collectionConfig)
    _{@context.lowerUnderscoreToUpperUnderscore(collectionConfig.getMethodBaseName)}_PATH_TEMPLATE
@end

@private pathTemplateSection(service)
    @if context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
        @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
            {@pathTemplateName(collectionConfig)} = PathTemplate(
                '{@collectionConfig.getNamePattern}')
        @end

        @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()

            {@createResourceFunction(collectionConfig)}
        @end
    @end
@end

@private createResourceFunction(collectionConfig)
    {@"@classmethod"}
    def {@collectionConfig.getMethodBaseName}_path(cls, {@createResourceFunctionParams(collectionConfig)}):
        """Returns a fully-qualified {@collectionConfig.getMethodBaseName} resource name string."""
        return cls.{@pathTemplateName(collectionConfig)}.instantiate({
            {@createInstantiateDictionary(collectionConfig)}
        })
@end

@private createResourceFunctionParams(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on ", "
        {@param}
    @end
@end

@private createInstantiateDictionary(collectionConfig)
    @join param: collectionConfig.getNameTemplate.vars() on BREAK
        '{@param}': {@param},
    @end
@end

@private comments(element)
    @join comment : context.comments(element, importHandler)
        {@comment}
    @end
@end

@private genericMethodsSection()
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def close(self):
        del self.stub
@end

@private serviceMethodsSection(service)
    @# Service calls
    @join method : service.getMethods on BREAK.add(BREAK)
        {@flattenedMethod(service, method)}
    @end
@end

@private callableConstructor(method)
    return api_callable.ApiCallable(
        self.stub.{@method.getSimpleName()}, settings=settings)(req)
@end

@private flattenedMethod(service, method)
    @let methodName = context.upperCamelToLowerUnderscore(method.getSimpleName()), \
             methodInputModule = pyproto.getPbFileName(method.getInputMessage()), \
             inputTypeName = method.getInputMessage().getSimpleName(), \
             flattenedParams = context.messages.flattenedFields(method.getInputType()), \
             documentation = comments(method), \
             methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             isPageStreamingRequest = methodConfig.isPageStreaming()
        @if flattenedParams
            def {@methodName}(
                    self,
                    {@parameterValues(flattenedParams)},
                    options=None):
                @if documentation
                    {@documentation}
                @end
                @if {@defaultMutableValues(flattenedParams)}
                    {@defaultMutableValues(flattenedParams)}
                @end
                req = {@methodInputModule}.{@inputTypeName}(
                    {@namedParameters(flattenedParams)})
                settings = self._defaults['{@methodName}'].merge(options)
                {@callableConstructor(method)}
        @else
            def {@methodName}(
                    self,
                    options=None):
                @if documentation
                    {@documentation}
                @end
                req = {@methodInputModule}.{@inputTypeName}()
                settings = self._defaults['{@methodName}'].merge(options)
                {@callableConstructor(method)}
        @end
    @end
@end

@private parameterValues(flattenedParams)
    @join field : flattenedParams on ",".add(BREAK)
        @let paramName = {@context.wrapIfKeywordOrBuiltIn(field.getSimpleName())}
            @if {@context.isDefaultValueMutable(field)}
                {@paramName}=None
            @else
                {@paramName}={@context.defaultValue(field, importHandler)}
            @end
        @end
    @end
@end

@private defaultMutableValues(flattenedParams)
    @join field : flattenedParams if {@context.isDefaultValueMutable(field)} on BREAK
        @let paramName = {@context.wrapIfKeywordOrBuiltIn(field.getSimpleName())}
            if {@paramName} is None:
                {@paramName} = {@context.defaultValue(field, importHandler)}
        @end
    @end
@end

@private namedParameters(flattenedParams)
    @join field : flattenedParams on ",".add(BREAK)
        @let paramName = {@field.getSimpleName()}
            {@paramName}={@context.wrapIfKeywordOrBuiltIn(field.getSimpleName())}
        @end
    @end
@end
