@snippet generateFilename(service)
  {@context.getExtensionsClassName(service)}.cs
@end

@snippet generateClass(service, body, imports)
  //
  // Copyright 2015, Google Inc. All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  //    Redistributions of source code must retain the above copyright
  // notice, this list of conditions and the following disclaimer.
  //    Redistributions in binary form must reproduce the above
  // copyright notice, this list of conditions and the following disclaimer
  // in the documentation and/or other materials provided with the
  // distribution.
  //
  //    Neither the name of Google Inc. nor the names of its
  // contributors may be used to endorse or promote products derived from
  // this software without specific prior written permission.
  //
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  // EDITING INSTRUCTIONS
  // This file was generated from the file {@service.getFile.getLocation.getDisplayString},
  // and updates to that file get reflected here through a regular refresh process.
  // This file should not be edited manually. Further extension methods can be added in
  // separate classes.
  @join import : imports
    using {@import};
  @end
  namespace {@context.getNamespace(service.getFile)}
  {
      {@body}
  }
@end

@snippet generateBody(service)
  {@addCommonImports()}
  /// <summary>
  /// Extension methods for {@context.getClientName(service)}. These are purely
  /// convenience methods for the regular calls, constructing requests from parameters.
  /// </summary>
  public static class {@context.getExtensionsClassName(service)}
  {
      {@flattenedMethods(service)}
  }
@end

@private addCommonImports() fill
  {@context.addImport("Grpc.Core")}
  {@context.addImport("Google.Protobuf")}
  {@context.addImport("Google.Protobuf.Collections")}
@end

@private flattenedMethods(service)
  @let serviceName = service.getSimpleName, \
       grpcName = context.getGrpcName(service)
    @join method : service.getMethods

      @let callableConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           methodName = method.getSimpleName, \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType)
        {@flattenedMethod(method, methodName, service)}
      @end
    @end
  @end
@end

@private flattenedMethod(method, methodName, service)
  {@flattenedMethodXmlDoc(method)}
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       inType = method.getInputType, \
       returnStatement = context.methodReturnStatement(method.getOutputType), \
       requestMethodName = context.typeName(method.getInputType), \
       clientName = context.getClientName(service)
    public static {@returnType} {@methodName}(this {@clientName} @@this{@context.prependComma({@flattenedParameters(inType)})})
    {
        @if {@context.messages.flattenedFields(inType).isEmpty}
          {@context.typeName(inType)} request = new {@context.typeName(inType)}();
        @else
          {@context.typeName(inType)} request = new {@context.typeName(inType)}
          {
              {@propertySetCalls(inType)}
          };
        @end

        {@returnStatement}@@this.{@methodName}(request);
    }
  @end
@end

@private propertySetCalls(inType)
  @join field : context.messages.flattenedFields(inType)
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      @if field.isRepeated
        {@propertyName(field)} = { {@paramName} },
      @else
        {@propertyName(field)} = {@paramName},
      @end
    @end
  @end
@end

@private propertyName(field)
  {@context.lowerUnderscoreToUpperCamel(field.getSimpleName)}
@end

@private flattenedMethodXmlDoc(method)
  {@xmlDoc(method)}
  @join field : context.messages.flattenedFields(method.getInputType) vertical
    @join commentLine : context.getXmlParameterLines(getDoc(field), context.lowerUnderscoreToLowerCamel(field.getSimpleName))
      {@commentLine}
    @end
  @end
@end

@private xmlDoc(protoElement)
  @join commentLine : context.getXmlDocLines(getDoc(protoElement), "summary")
    {@commentLine}
  @end
@end

@private getDoc(protoElement)
  {@context.getDescription(protoElement)}
@end

@private flattenedParameters(inType)
  @join field : context.messages.flattenedFields(inType) on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@context.typeName(field.getType)} {@paramName}
    @end
  @end
@end

@private flattenedArguments(inType)
  @join field : context.messages.flattenedFields(inType) on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@paramName}
    @end
  @end
@end
