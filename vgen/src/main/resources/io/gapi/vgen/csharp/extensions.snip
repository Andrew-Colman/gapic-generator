@snippet generateFilename(service)
  {@context.getExtensionsClassName(service)}.cs
@end

@snippet generateClass(service, body, imports)
  //
  // Copyright 2015, Google Inc. All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  //    Redistributions of source code must retain the above copyright
  // notice, this list of conditions and the following disclaimer.
  //    Redistributions in binary form must reproduce the above
  // copyright notice, this list of conditions and the following disclaimer
  // in the documentation and/or other materials provided with the
  // distribution.
  //
  //    Neither the name of Google Inc. nor the names of its
  // contributors may be used to endorse or promote products derived from
  // this software without specific prior written permission.
  //
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  // EDITING INSTRUCTIONS
  // This file was generated from the file {@service.getFile.getLocation.getDisplayString},
  // and updates to that file get reflected here through a regular refresh process.
  // This file should not be edited manually. Further extension methods can be added in
  // separate classes.
  
  @join import : imports
    using {@import};
  @end

  namespace {@context.getNamespace(service.getFile)}
  {
      {@body}
  }
@end

@snippet generateBody(service)
  {@addCommonImports()}
  /// <summary>
  /// Extension methods for {@context.getClientName(service)}. These are purely
  /// convenience methods for the regular calls, constructing requests from parameters.
  /// </summary>
  public static class {@context.getExtensionsClassName(service)}
  {
      {@pageStreamers(service)}
      {@flattenedMethods(service)}
  }
@end

@private addCommonImports() fill
  {@context.addImport("Grpc.Core")}
  {@context.addImport("Google.Apis.Common")}
  {@context.addImport("Google.Protobuf")}
  {@context.addImport("Google.Protobuf.Collections")}
  {@context.addImport("System.Threading")}
  {@context.addImport("System.Threading.Tasks")}
@end

@private pageStreamers(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service)
    @join method : context.messages.filterPageStreamingMethods(interfaceConfig, service.getMethods)
      @let methodConfig = interfaceConfig.getMethodConfig(method), \
           pageStreaming = methodConfig.getPageStreaming(), \
           resourceTypeName = context.basicTypeName(pageStreaming.getResourcesField().getType), \
           responseTypeName = context.typeName(method.getOutputType), \
           requestTypeName = context.typeName(method.getInputType), \
           tokenTypeName = context.typeName(pageStreaming.getRequestTokenField().getType), \
           clientName = context.getClientName(service)
        private static readonly PageStreamer<{@resourceTypeName}, {@requestTypeName}, {@responseTypeName}, {@tokenTypeName}> s_{@method.getSimpleName}PageStreamer =
            new PageStreamer<{@resourceTypeName}, {@requestTypeName}, {@responseTypeName}, {@tokenTypeName}>(
                (request, token) => { request.{@propertyName(pageStreaming.getRequestTokenField)} = token; return request; },
                response => response.{@propertyName(pageStreaming.getResponseTokenField)},
                response => response.{@propertyName(pageStreaming.getResourcesField)},
                {@tokenTypeName}.Empty);

      @end
      # Make sure we import collection types, but only if we need to.
      {@context.addImport("System.Collections.Generic")}
    @end
  @end
@end

@private flattenedMethods(service)
  @join method : service.getMethods
    @let methodName = method.getSimpleName, \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
         isPageStreaming = methodConfig.isPageStreaming, \
         isFlattening = methodConfig.isFlattening
      @if {@isPageStreaming}
        @if {@isFlattening}
          @join flatteningGroup: \
              methodConfig.getFlattening().getFlatteningGroups()
            {@iterableFlattenedMethod(method, methodName, service, flatteningGroup)}
          @end
        @end
      @else
        @if {@isFlattening}
          @join flatteningGroup : \
              methodConfig.getFlattening().getFlatteningGroups()
            {@flattenedMethod(method, methodName, service, flatteningGroup)}
          @end
        @end
      @end
    @end
  @end
@end

@private iterableFlattenedMethod(method, methodName, service, fields)
  @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
       pageStreaming = methodConfig.getPageStreaming(), \
       resourceElementTypeName = context.basicTypeName(pageStreaming.getResourcesField().getType), \
       clientName = context.getClientName(service)
    {@flattenedMethodXmlDoc(method)}
    public static IEnumerable<{@resourceElementTypeName}> \
        {@methodName}(this {@clientName} @@this{@context.prependComma({@flattenedParameters(fields)})})
    {
        {@requestCreation(method, fields)}

        return s_{@method.getSimpleName}PageStreamer.Fetch(request, req => @@this.{@methodName}(req));
    }

    {@flattenedMethodXmlDoc(method)}
    public static IAsyncEnumerable<{@resourceElementTypeName}> \
        {@methodName}Async(this {@clientName} @@this{@context.prependComma({@flattenedParameters(fields)})})
    {
        {@requestCreation(method, fields)}

        return s_{@method.getSimpleName}PageStreamer.FetchAsync(request, (req, cancellationToken) => @@this.{@methodName}Async(req).ResponseAsync);
    }
  @end
@end

@private flattenedMethod(method, methodName, service, fields)
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       returnStatement = context.methodReturnStatement(method.getOutputType), \
       clientName = context.getClientName(service)
    {@flattenedMethodXmlDoc(method)}
    public static {@returnType} {@methodName}(this {@clientName} @@this{@context.prependComma({@flattenedParameters(fields)})})
    {
        {@requestCreation(method, fields)}

        {@returnStatement}@@this.{@methodName}(request);
    }

  @end
  @let returnType = context.asyncMethodReturnTypeName(method.getOutputType), \
       clientName = context.getClientName(service)
    {@flattenedMethodXmlDoc(method)}
    /// <paramref name="cancellationToken">
    /// The cancellation token for the asynchronous operation. This defaults to the default
    /// cancellation token, equivalent to <see cref="CancellationToken.None" />.
    /// </paramref>
    public static {@returnType} {@methodName}Async(this {@clientName} @@this{@context.prependComma({@flattenedParameters(fields)})}, \
        CancellationToken cancellationToken = default(CancellationToken))
    {
        {@requestCreation(method, fields)}

        return @@this.{@methodName}Async(request, cancellationToken: cancellationToken).ResponseAsync;
    }

  @end
@end

@private requestCreation(method, fields)
  @let requestTypeName = context.typeName(method.getInputType)
    @if {@fields.isEmpty}
      {@requestTypeName} request = new {@requestTypeName}();
    @else
      {@requestTypeName} request = new {@requestTypeName}
      {
          @join field : fields
            @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
              @if field.isRepeated
                  {@propertyName(field)} = { {@paramName} },
              @else
                  {@propertyName(field)} = {@paramName},
              @end
            @end
          @end
      };
    @end
  @end
@end

@private propertyName(field)
  {@context.lowerUnderscoreToUpperCamel(field.getSimpleName)}
@end

@private flattenedMethodXmlDoc(method)
  {@xmlDoc(method)}
  @join field : context.messages.flattenedFields(method.getInputType) vertical
    @join commentLine : context.getXmlParameterLines(getDoc(field), context.lowerUnderscoreToLowerCamel(field.getSimpleName))
      {@commentLine}
    @end
  @end
@end

@private xmlDoc(protoElement)
  @join commentLine : context.getXmlDocLines(getDoc(protoElement), "summary")
    {@commentLine}
  @end
@end

@private getDoc(protoElement)
  {@context.getDescription(protoElement)}
@end

@private flattenedParameters(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@context.typeName(field.getType)} {@paramName}
    @end
  @end
@end

@private flattenedArguments(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@paramName}
    @end
  @end
@end
