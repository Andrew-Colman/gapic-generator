@snippet generateFilename(service)
  {@context.getVeneerName(service)}.java
@end

@snippet generateClass(service, body, imports)
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   */

  /*
   * EDITING INSTRUCTIONS
   * This file was generated from the file
   * https://github.com/google/googleapis/blob/master/{@service.getFile().getSimpleName()}
   * and updates to that file get reflected here through a refresh process.
   * For the short term, the refresh process will only be runnable by Google engineers.
   * Manual additions are allowed because the refresh process performs
   * a 3-way merge in order to preserve those manual additions. In order to not
   * break the refresh process, only certain types of modifications are
   * allowed.
   *
   * Allowed modifications - currently these are the only types allowed:
   * 1. New methods (these should be added to the end of the class)
   * 2. New imports
   * 3. Additional documentation between "manual edit" demarcations
   *
   * Happy editing!
   */
  package {@context.getApiConfig.getPackageName};

  @join import : imports
    import {@import};
  @end

  // Manually-added imports: add custom (non-generated) imports after this point.

  {@body}
@end

@snippet generateBody(service)
  {@alwaysImport()}

  {@serviceJavaDoc(service)}
  @@javax.annotation.Generated("by the veneer generator")
  public class {@context.getVeneerName(service)} implements AutoCloseable {

    {@methodIdentityEnum(service)}

    {@constants(service)}

    {@members(service)}

    {@constructors(service)}

    {@resourceFunctions(service)}

    {@callables(service)}

    {@cleanupSection()}

    {@manualSection()}
  }
@end

@private alwaysImport() fill
  {@context.addImport("com.google.api.gax.core.BackoffParams")}
  {@context.addImport("com.google.api.gax.core.RetryParams")}
  {@context.addImport("com.google.api.gax.grpc.ApiCallable")}
  {@context.addImport("com.google.api.gax.grpc.ServiceApiSettings")}
  {@context.addImport("com.google.api.gax.internal.ApiUtils")}
  {@context.addImport("com.google.api.gax.protobuf.PathTemplate")}
  {@context.addImport("com.google.common.collect.ImmutableMap")}
  {@context.addImport("com.google.common.collect.ImmutableSet")}
  {@context.addImport("com.google.common.collect.Lists")}
  {@context.addImport("com.google.common.collect.Maps")}
  {@context.addImport("com.google.common.collect.Sets")}
  {@context.addImport("io.grpc.ManagedChannel")}
  {@context.addImport("io.grpc.Status")}
  {@context.addImport("java.io.IOException")}
  {@context.addImport("java.util.EnumMap")}
  {@context.addImport("java.util.HashMap")}
  {@context.addImport("java.util.Map")}
@end

@private methodIdentityEnum(service)
  public enum MethodIdentifier {
    @join method : service.getMethods on ", "
      {@context.upperCamelToUpperUnderscore(method.getSimpleName)}
    @end
  }
@end

@private constants(service)
  // =========
  // Constants
  // =========

  {@pathAndPortConstants(service)}
  {@retryDefConstant(service)}
  {@callableConstants(service)}
  {@pageDescriptorConstants(service)}
  {@scopeConstant(service)}
  {@pathTemplateConstants(service)}
@end

@private pathAndPortConstants(service)
  /**
   * The default address of the service.
   *
  {@javaDocManualEdit()}
   */
  public static final String SERVICE_ADDRESS = "{@context.getServiceConfig.getServiceAddress(service)}";

  /**
   * The default port of the service.
   *
  {@javaDocManualEdit()}
   */
  public static final int DEFAULT_SERVICE_PORT = {@context.getServiceConfig.getServicePort()};

@end

@private retryDefConstant(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service)
    private static final ImmutableMap<MethodIdentifier, ImmutableSet<Status.Code>> DEFAULT_RETRY_CONFIG;

    static {
      Map<String, ImmutableSet<Status.Code>> definition = new HashMap<>();
      @join retryDef : context.entrySet(interfaceConfig.getRetryCodesDefinition)
        definition.put(
            "{@retryDef.getKey}",
            Sets.immutableEnumSet(Lists.<Status.Code>newArrayList({@statusCodes(retryDef.getValue)})));
      @end

      Map<MethodIdentifier, ImmutableSet<Status.Code>> retryableCodes = new EnumMap<>(MethodIdentifier.class);
      @join method : service.getMethods
        @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             methodEnumName = context.upperCamelToUpperUnderscore(method.getSimpleName), \
             retryName = methodConfig.getRetryCodesConfigName
          @if retryName.isEmpty
            retryableCodes.put(MethodIdentifier.{@methodEnumName}, ImmutableSet.<Status.Code>of());
          @else
            retryableCodes.put(MethodIdentifier.{@methodEnumName}, definition.get("{@retryName}"));
          @end
        @end
      @end
      DEFAULT_RETRY_CONFIG = Maps.<MethodIdentifier, ImmutableSet<Status.Code>>immutableEnumMap(retryableCodes);
    }

    private static final ImmutableMap<MethodIdentifier, RetryParams> DEFAULT_RETRY_PARAMS;

    static {
      Map<String, RetryParams> definition = new HashMap<>();
      RetryParams params = null;
      @join retryDef : context.entrySet(interfaceConfig.getRetryParamsDefinition)
        params = RetryParams.newBuilder()
            .setRetryBackoff(
                BackoffParams.newBuilder()
                    .setInitialDelayMillis({@retryDef.getValue.getRetryBackoff.getInitialDelayMillis}L)
                    .setDelayMultiplier({@retryDef.getValue.getRetryBackoff.getDelayMultiplier})
                    .setMaxDelayMillis({@retryDef.getValue.getRetryBackoff.getMaxDelayMillis}L)
                    .build())
            .setTimeoutBackoff(
                BackoffParams.newBuilder()
                    .setInitialDelayMillis({@retryDef.getValue.getTimeoutBackoff.getInitialDelayMillis}L)
                    .setDelayMultiplier({@retryDef.getValue.getTimeoutBackoff.getDelayMultiplier})
                    .setMaxDelayMillis({@retryDef.getValue.getTimeoutBackoff.getMaxDelayMillis}L)
                    .build())
            .setTotalTimeout({@retryDef.getValue.getTotalTimeout}L)
            .build();
        definition.put("{@retryDef.getKey}", params);
      @end

      Map<MethodIdentifier, RetryParams> retryParams = new EnumMap<>(MethodIdentifier.class);
      @join method :service.getMethods
        @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             methodEnumName = context.upperCamelToUpperUnderscore(method.getSimpleName), \
             retryName = methodConfig.getRetryParamsConfigName
          retryParams.put(MethodIdentifier.{@methodEnumName}, definition.get("{@retryName}"));
        @end
      @end
      DEFAULT_RETRY_PARAMS = Maps.<MethodIdentifier, RetryParams>immutableEnumMap(retryParams);
    }
  @end
@end

@private statusCodes(codes)
  @join code : codes on ", "
    Status.Code.{@code}
  @end
@end

@private callableConstants(service)
  @let serviceName = service.getSimpleName, \
       grpcName = context.getGrpcName(service)

    @join method : service.getMethods
      @let callableConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType)
        private static final ApiCallable<{@inTypeName}, {@outTypeName}>
            {@callableConstant} = ApiCallable.create({@grpcName}.METHOD_{@callableConstant});
            # TODO: MIGRATION
            # figure from where to get the service descriptor, or get rid of its need
            # via vgen detail config
            #    {@serviceName}.getServiceDescriptor().findMethodByName("{@method.getSimpleName}"));
      @end
    @end

  @end
@end

@private pageDescriptorConstants(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service)
    @join method : context.messages.filterPageStreamingMethods(interfaceConfig, service.getMethods)
      @let methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType), \
           pageStreaming = interfaceConfig.getMethodConfig(method).getPageStreaming(), \
           resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
           tokenTypeName = context.typeName(pageStreaming.getResponseTokenField.getType)
        private static PageDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}> {@methodConstant}_PAGE_DESC =
            new PageDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}>() {
              @@Override
              public Object emptyToken() {
                return {@context.defaultTokenValue(pageStreaming.getRequestTokenField())};
              }
              @@Override
              public {@inTypeName} injectToken(
                  {@inTypeName} payload, Object token) {
                return {@inTypeName}
                  .newBuilder(payload)
                  .{@setCallName(pageStreaming.getRequestTokenField())}(({@tokenTypeName}) token)
                  .build();
              }
              @@Override
              public Object extractNextToken({@outTypeName} payload) {
                return payload.{@getCallName(pageStreaming.getResponseTokenField())}();
              }
              @@Override
              public Iterable<{@resourceTypeName}> extractResources({@outTypeName} payload) {
                return payload.{@getCallName(pageStreaming.getResourcesField())}();
              }
            };

      @end
    @end
  @end
@end

@private scopeConstant(service)
  private static String ALL_SCOPES[] = {
    @join scope : context.getServiceConfig.getAuthScopes(service)
      "{@scope}",
    @end
  };

@end

@private pathTemplateConstants(service)
  @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
    {@pathTemplateConstant(collectionConfig)}
  @end
@end

@private pathTemplateConstant(collectionConfig)
  /**
   * A PathTemplate representing the fully-qualified path to represent
   * a {@collectionConfig.getMethodBaseName} resource.
   *
  {@javaDocManualEdit()}
   */
  private static final PathTemplate {@pathTemplateConstantName(collectionConfig)} =
      PathTemplate.create("{@collectionConfig.getNamePattern}");
@end

@private pathTemplateConstantName(collectionConfig)
  {@context.lowerUnderscoreToUpperUnderscore(collectionConfig.getMethodBaseName)}_PATH_TEMPLATE
@end

@private resourceFunctions(service)
  // ==============================
  // Resource Name Helper Functions
  // ==============================

  @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
    {@createResourceFunction(collectionConfig)}
  @end

  @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
    {@extractResourceFunctions(collectionConfig)}
  @end
@end

@private createResourceFunction(collectionConfig)
  /**
   * Creates a string containing the fully-qualified path to represent
   * a {@collectionConfig.getMethodBaseName} resource.
   *
  {@javaDocManualEdit()}
   */
  public static final String {@createResourceFunctionName(collectionConfig)}(\
      {@createResourceFunctionParams(collectionConfig)}) {
    return {@pathTemplateConstantName(collectionConfig)}.instantiate(
        {@pathTemplateArgs(collectionConfig)});
  }

@end

@private createResourceFunctionName(collectionConfig)
  create{@resourcePath(collectionConfig)}
@end

@private createResourceFunctionParams(collectionConfig)
  @join param : collectionConfig.getNameTemplate.vars() on ", "
    String {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private pathTemplateArgs(collectionConfig)
  @join param : collectionConfig.getNameTemplate.vars() vertical on ","
    "{@param}", {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private extractResourceFunctions(collectionConfig)
  @join subField : collectionConfig.getNameTemplate.vars()
    @let fieldPath = context.upperCamelToLowerCamel(resourcePath(collectionConfig))
      /**
       * Extracts the {@subField} from the given fully-qualified path which
       * represents a {@context.lowerUnderscoreToLowerCamel(collectionConfig.getMethodBaseName)} resource.
       *
      {@javaDocManualEdit()}
       */
      public static final String \
          extract{@context.lowerUnderscoreToUpperCamel(subField)}From{@resourcePath(collectionConfig)}(\
          String {@fieldPath}) {
        return {@pathTemplateConstantName(collectionConfig)}.parse({@fieldPath}).get("{@subField}");
      }

    @end
  @end
@end

@private resourcePath(collectionConfig)
  {@context.lowerUnderscoreToUpperCamel(collectionConfig.getMethodBaseName)}Path
@end

@private members(service)
  // ========
  // Members
  // ========

  private final ManagedChannel channel;
  private final ServiceApiSettings<MethodIdentifier> settings;
  private final ImmutableMap<MethodIdentifier, ImmutableSet<Status.Code>> retryCodesConfig;
  private final ImmutableMap<MethodIdentifier, RetryParams> retryParamsConfig;
@end

@private constructors(service)
  @let veneerName = context.getVeneerName(service)
    // ===============
    // Factory Methods
    // ===============

    /**
     * Constructs an instance of {@veneerName} with default settings.
     *
    {@javaDocManualEdit()}
     */
    public static {@veneerName} create() throws IOException {
      return create(ServiceApiSettings.<MethodIdentifier>builder().build());
    }

    /**
     * Constructs an instance of {@veneerName}, using the given settings. The channels are created based
     * on the settings passed in, or defaults for any settings that are not set.
     *
    {@javaDocManualEdit()}
     */
    public static {@veneerName} create(ServiceApiSettings<MethodIdentifier> settings) throws IOException {
      return new {@veneerName}(settings);
    }

    /**
     * Constructs an instance of {@veneerName}, using the given settings. This is protected so that it
     * easy to make a subclass, but otherwise, the static factory methods should be preferred.
     *
    {@javaDocManualEdit()}
     */
    protected {@veneerName}(ServiceApiSettings<MethodIdentifier> settings) throws IOException {
      ServiceApiSettings<MethodIdentifier> internalSettings = ApiUtils.populateSettings(settings,
          SERVICE_ADDRESS, DEFAULT_SERVICE_PORT, ALL_SCOPES);
      this.settings = internalSettings;
      this.channel = internalSettings.getChannel();

      Map<MethodIdentifier, ImmutableSet<Status.Code>> retryCodesConfig =
          new EnumMap<>(DEFAULT_RETRY_CONFIG);
      retryCodesConfig.putAll(settings.getRetryableCodes());
      this.retryCodesConfig =
          Maps.<MethodIdentifier, ImmutableSet<Status.Code>>immutableEnumMap(retryCodesConfig);

      Map<MethodIdentifier, RetryParams> retryParamsConfig = new EnumMap<>(DEFAULT_RETRY_PARAMS);
      retryParamsConfig.putAll(settings.getRetryParams());
      this.retryParamsConfig =
          Maps.<MethodIdentifier, RetryParams>immutableEnumMap(retryParamsConfig);
    }
  @end
@end

@private callables(service)
  // =============
  // Service Calls
  // =============

  @join method : service.getMethods
    @let callableConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
         methodName = context.upperCamelToLowerCamel(method.getSimpleName), \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         requestFactoryName = context.getRequestFactoryName(service), \
         methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
         isPageStreaming = methodConfig.isPageStreaming, \
         isFlattening = methodConfig.isFlattening
      // ----- {@methodName} -----

      # TODO (garrettjones) put some kind of limit on number of flattened parameters, and
      # don't generated a flattened method if there are too many.
      @if {@isPageStreaming}
        @if {@isFlattening}
          @join flatteningGroup: \
              methodConfig.getFlattening().getFlatteningGroups()
            {@iterableFlattenedMethod(service, method, methodName, requestFactoryName, flatteningGroup)}
          @end
          {@BREAK}
        @end
        {@iterableMethodWithRequestParam(service, method, methodName, inTypeName, outTypeName)}
        {@methodReturningStreamingCallable(service, method, methodName, inTypeName, outTypeName)}
      @else
        @if {@isFlattening}
          @join flatteningGroup : \
              methodConfig.getFlattening().getFlatteningGroups()
            {@flattenedMethod(method, methodName, requestFactoryName, flatteningGroup)}
          @end
          {@BREAK}
        @end
        {@methodWithRequestParam(method, methodName, inTypeName, outTypeName)}
      @end
      {@methodReturningCallable(method, callableConstant, methodName, inTypeName, outTypeName)}
    @end
  @end
@end

@private cleanupSection()
  // ========
  // Cleanup
  // ========

  /**
   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately
   * cancelled.
   *
  {@javaDocManualEdit()}
   */
  @@Override
  public void close() {
    // Manually-added shutdown code

    // Auto-generated shutdown code
    channel.shutdown();

    // Manually-added shutdown code
  }

@end

@private manualSection()
  // ========
  // Manually-added methods: add custom (non-generated) methods after this point.
  // ========

@end

@private iterableFlattenedMethod(service, method, methodName, requestFactoryName, fields)
  {@methodJavaDoc(method)}
  @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
       pageStreaming = methodConfig.getPageStreaming(), \
       resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
       requestTypeName = context.typeName(method.getInputType)
    public Iterable<{@resourceTypeName}> \
        {@methodName}({@flattenedParameters(fields)}) {
      {@context.typeName(method.getInputType)} request =
          {@requestTypeName}.newBuilder()
          {@builderSetCalls(fields)}
          .build();
      return {@methodName}(request);
    }

  @end
@end

@private iterableMethodWithRequestParam(service, method, methodName, inTypeName, outTypeName)
  {@methodWithRequestParamJavaDoc(method)}
  @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
       pageStreaming = methodConfig.getPageStreaming(), \
       resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
       dummy = context.addImport("com.google.api.gax.grpc.PageDescriptor")
    public Iterable<{@resourceTypeName}> {@methodName}({@inTypeName} request) {
      return {@methodName}StreamingCallable()
          .call(request);
    }

  @end
@end

@private methodReturningStreamingCallable(service, method, methodName, inTypeName, outTypeName)
  {@methodJavaDoc(method)}
  @let methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
       pageStreaming = methodConfig.getPageStreaming(), \
       resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
       methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName)
    public ApiCallable<{@inTypeName}, Iterable<{@resourceTypeName}>> {@methodName}StreamingCallable() {
      return {@methodName}Callable().pageStreaming({@methodConstant}_PAGE_DESC);
    }

  @end
@end

@private flattenedMethod(method, methodName, requestFactoryName, fields)
  {@flattenedMethodJavaDoc(method, fields)}
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       returnStatement = context.methodReturnStatement(method.getOutputType), \
       requestTypeName = context.typeName(method.getInputType)
    public {@returnType} {@methodName}({@flattenedParameters(fields)}) {
      {@context.typeName(method.getInputType)} request =
          {@requestTypeName}.newBuilder()
          {@builderSetCalls(fields)}
          .build();

      {@returnStatement}{@methodName}(request);
    }

  @end
@end

@private methodWithRequestParam(method, methodName, inTypeName, outTypeName)
  {@methodWithRequestParamJavaDoc(method)}
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       returnStatement = context.methodReturnStatement(method.getOutputType)
    public {@returnType} {@methodName}({@inTypeName} request) {
      {@returnStatement}{@methodName}Callable().call(request);
    }

  @end
@end

@private methodReturningCallable(method, callableConstant, methodName, inTypeName, outTypeName)
  {@methodJavaDoc(method)}
  public ApiCallable<{@inTypeName}, {@outTypeName}> {@methodName}Callable() {
    ImmutableSet<Status.Code> retryableCodes =
        retryCodesConfig.get(MethodIdentifier.{@callableConstant});
    RetryParams retryParams =
        retryParamsConfig.get(MethodIdentifier.{@callableConstant});
    return {@callableConstant}.retryableOn(retryableCodes).retrying(retryParams).bind(channel);
  }

@end

@private serviceJavaDoc(protoElement)
  {@autoGenServiceWarning()}
  {@javaDoc(protoElement)}
@end

@private methodJavaDoc(protoElement)
  {@autoGenMethodWarning()}
  {@javaDoc(protoElement)}
@end

@private methodWithRequestParamJavaDoc(protoElement)
  {@autoGenMethodWarning()}
  {@javaDocStart()}
  {@javaDocLines(protoElement)}
  {@javaDocEmptyLine()}
  {@javaDocManualEdit()}
  {@javaDocEmptyLine()}
  {@javaDocGenericRequestParam()}
  {@javaDocEnd()}
@end

@private flattenedMethodJavaDoc(method, fields)
  {@autoGenMethodWarning()}
  {@javaDocStart()}
  {@javaDocLines(method)}
  {@javaDocEmptyLine()}
  {@javaDocManualEdit()}
  {@javaDocEmptyLine()}
  @join field : fields vertical
    @join commentLine : context.getJavaDocLinesWithPrefix(getDoc(field), paramDocLinePrefix(field))
      {@commentLine}
    @end
  @end
  {@javaDocEnd()}
@end

@private autoGenServiceWarning()
  // AUTO-GENERATED DOCUMENTATION AND SERVICE - see instructions at the top of the file for editing.
@end

@private autoGenMethodWarning()
  // AUTO-GENERATED DOCUMENTATION AND METHOD - see instructions at the top of the file for editing.
@end

@private paramDocLinePrefix(field)
  @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName), \
      lineBarrier = ""
    @@param {@paramName} {@lineBarrier}
  @end
@end

@private javaDoc(protoElement)
  {@javaDocStart()}
  {@javaDocLines(protoElement)}
  {@javaDocEmptyLine()}
  {@javaDocManualEdit()}
  {@javaDocEnd()}
@end

@private javaDocLines(protoElement)
  @join commentLine : context.getJavaDocLines(getDoc(protoElement))
    {@commentLine}
  @end
@end

@private javaDocStart()
  /**
@end

@private javaDocEmptyLine()
  @let lineBarrier = ""
    {@lineBarrier} *
  @end
@end

@private javaDocGenericRequestParam()
  @let lineBarrier = ""
    {@lineBarrier} * @@param request The request object containing all \
        of the parameters for the API call.
  @end
@end

@private javaDocManualEdit()
  @let lineBarrier = ""
    {@lineBarrier} * <!-- manual edit -->
    {@lineBarrier} * <!-- end manual edit -->
  @end
@end

@private javaDocEnd()
  @let lineBarrier = ""
    {@lineBarrier} */
  @end
@end

@private getDoc(protoElement)
  {@context.getDescription(protoElement)}
@end

@private flattenedParameters(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@context.typeName(field.getType)} {@paramName}
    @end
  @end
@end

@private flattenedArguments(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@paramName}
    @end
  @end
@end

@private builderSetCalls(fields)
  @join field : fields
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      .{@setCallName(field)}({@paramName})
    @end
  @end
@end

@private setCallName(field)
  @let paramNameInCamel = context.lowerUnderscoreToUpperCamel(field.getSimpleName)
    @if field.getType.isMap
      putAll{@paramNameInCamel}
    @else
      @if field.isRepeated
        addAll{@paramNameInCamel}
      @else
        set{@paramNameInCamel}
      @end
    @end
  @end
@end

@private getCallName(field)
  @let paramNameInCamel = context.lowerUnderscoreToUpperCamel(field.getSimpleName)
    @if field.isRepeated
      get{@paramNameInCamel}List
    @else
      get{@paramNameInCamel}
    @end
  @end
@end
