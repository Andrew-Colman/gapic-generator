@snippet generateFilename(service)
  {@context.getVeneerName(service)}.java
@end

@snippet generateClass(service, body, imports)
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   */

  /*
   * EDITING INSTRUCTIONS
   * This file was generated from the file
   * https://github.com/google/googleapis/blob/master/{@service.getFile().getSimpleName()}
   * and updates to that file get reflected here through a refresh process.
   * For the short term, the refresh process will only be runnable by Google engineers.
   * Manual additions are allowed because the refresh process performs
   * a 3-way merge in order to preserve those manual additions. In order to not
   * break the refresh process, only certain types of modifications are
   * allowed.
   *
   * Allowed modifications - currently these are the only types allowed:
   * 1. New methods (these should be added to the end of the class)
   * 2. New imports
   *
   * Happy editing!
   */
  package {@context.getApiConfig.getPackageName};

  @join import : imports
    import {@import};
  @end

  // Manually-added imports: add custom (non-generated) imports after this point.

  {@body}
@end

@snippet generateBody(service)
  {@alwaysImport()}

  {@serviceJavaDoc(service)}
  @@javax.annotation.Generated("by the veneer generator")
  public class {@context.getVeneerName(service)} implements AutoCloseable {

    {@constants(service)}

    {@members(service)}

    {@constructors(service)}

    {@resourceFunctions(service)}

    {@callables(service)}

    {@cleanupSection()}

    {@manualSection()}
  }
@end

@private alwaysImport() fill
  {@context.addImport("io.gapi.gax.grpc.ApiCallable")}
  {@context.addImport("io.gapi.gax.grpc.ServiceApiSettings")}
  {@context.addImport("io.gapi.gax.internal.ApiUtils")}
  {@context.addImport("io.gapi.gax.protobuf.PathTemplate")}
  {@context.addImport("io.grpc.ManagedChannel")}
  {@context.addImport("java.io.IOException")}
@end

@private constants(service)
  // =========
  // Constants
  // =========

  {@pathAndPortConstants()}
  {@callableConstants(service)}
  {@pageDescriptorConstants(service)}
  {@scopeConstant()}
  {@pathTemplateConstants(service)}
@end

@private pathAndPortConstants()
  /**
   * The default address of the service.
   */
  # TODO (garrettjones) get this data from the yaml files of the service
  public static final String SERVICE_ADDRESS = "xyz.googleapis.com";

  /**
   * The default port of the service.
   */
  public static final int DEFAULT_SERVICE_PORT = 443;

@end

@private callableConstants(service)
  @let serviceName = service.getSimpleName, \
       grpcName = context.getGrpcName(service)

    @join method : service.getMethods
      @let callableConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType)
        private static final ApiCallable<{@inTypeName}, {@outTypeName}>
            {@callableConstant} = ApiCallable.create({@grpcName}.METHOD_{@callableConstant});
            # TODO: MIGRATION
            # figure from where to get the service descriptor, or get rid of its need
            # via vgen detail config
            #    {@serviceName}.getServiceDescriptor().findMethodByName("{@method.getSimpleName}"));
      @end
    @end

  @end
@end

@private pageDescriptorConstants(service)
  @join method : context.messages.filterPageStreamingMethods(context.getApiConfig, service.getMethods)
    @let methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         resourceTypeName = context.pageStreamingResourceType(method.getOutputType), \
         pageStreaming = context.getApiConfig.getMethodConfig(method).getPageStreaming()
      private static PageDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}> {@methodConstant}_PAGE_DESC =
          new PageDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}>() {
            @@Override
            public Object emptyToken() {
              return {@context.defaultTokenValue(pageStreaming.getRequestTokenField())};
            }
            @@Override
            public {@inTypeName} injectToken(
                {@inTypeName} payload, Object token) {
              return {@inTypeName}
                .newBuilder(payload)
                .{@setCallName(pageStreaming.getRequestTokenField())}((String) token)
                .build();
            }
            @@Override
            public Object extractNextToken({@outTypeName} payload) {
              return payload.{@getCallName(pageStreaming.getResponseTokenField())}();
            }
            @@Override
            public Iterable<{@resourceTypeName}> extractResources({@outTypeName} payload) {
              return payload.{@getCallName(pageStreaming.getResourcesField())}();
            }
          };

    @end
  @end
@end

@private scopeConstant()
  private static String ALL_SCOPES[] = {
    # TODO (garrettjones) get this data from the yaml files of the service
  };

@end

@private pathTemplateConstants(service)
  @join fieldSegment : context.resources.getFieldSegmentsFromHttpPaths(service.getMethods)
    {@pathTemplateConstant(fieldSegment)}
  @end
@end

@private pathTemplateConstant(fieldSegment)
  /**
   * A PathTemplate representing the fully-qualified path to represent
   * a {@fieldSegment.getFieldPath} resource.
   */
  private static final PathTemplate {@pathTemplateConstantName(fieldSegment)} =
      PathTemplate.create("{@context.resources.templatize(fieldSegment)}");
@end

@private pathTemplateConstantName(fieldSegment)
  {@context.lowerUnderscoreToUpperUnderscore(fieldSegment.getFieldPath)}_PATH_TEMPLATE
@end

@private resourceFunctions(service)
  // ==============================
  // Resource Name Helper Functions
  // ==============================

  @join fieldSegment : context.resources.getFieldSegmentsFromHttpPaths(service.getMethods)
    {@createResourceFunction(fieldSegment)}
  @end

  @join fieldSegment : context.resources.getFieldSegmentsFromHttpPaths(service.getMethods)
    {@extractResourceFunction(fieldSegment)}
  @end
@end

@private createResourceFunction(fieldSegment)
  /**
   * Creates a string containing the fully-qualified path to represent
   * a {@fieldSegment.getFieldPath} resource.
   */
  public static final String {@createResourceFunctionName(fieldSegment)}(\
      {@createResourceFunctionParams(fieldSegment)}) {
    return {@pathTemplateConstantName(fieldSegment)}.instantiate(
        {@pathTemplateArgs(fieldSegment)});
  }

@end
@private createResourceFunctionName(fieldSegment)
  create{@resourcePath(fieldSegment)}
@end

@private createResourceFunctionParams(fieldSegment)
  @join param : context.resources.getParamsForResourceNameWildcards(fieldSegment) on ", "
    String {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private pathTemplateArgs(fieldSegment)
  @join param : context.resources.getParamsForResourceNameWildcards(fieldSegment) vertical on ","
    "{@param}", {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private extractResourceFunction(fieldSegment)
  @join subField : context.resources.getParamsForResourceNameWildcards(fieldSegment)
    @let fieldPath = context.upperCamelToLowerCamel(resourcePath(fieldSegment))
      /**
       * Extracts the {@subField} from the given fully-qualified path which
       * represents a {@context.lowerUnderscoreToLowerCamel(fieldSegment.getFieldPath)} resource.
       */
      public static final String \
          extract{@context.lowerUnderscoreToUpperCamel(subField)}From{@resourcePath(fieldSegment)}(\
          String {@fieldPath}) {
        return {@pathTemplateConstantName(fieldSegment)}.parse({@fieldPath}).get("{@subField}");
      }

    @end
  @end
@end

@private resourcePath(fieldSegment)
  {@context.lowerUnderscoreToUpperCamel(fieldSegment.getFieldPath)}Path
@end

@private members(service)
  // ========
  // Members
  // ========

  private final ManagedChannel channel;
  private final ServiceApiSettings settings;
@end

@private constructors(service)
  @let veneerName = context.getVeneerName(service)
    // ===============
    // Factory Methods
    // ===============

    /**
     * Constructs an instance of {@veneerName} with default settings.
     */
    public static {@veneerName} create() throws IOException {
      return create(new ServiceApiSettings());
    }

    /**
     * Constructs an instance of {@veneerName}, using the given settings. The channels are created based
     * on the settings passed in, or defaults for any settings that are not set.
     */
    public static {@veneerName} create(ServiceApiSettings settings) throws IOException {
      return new {@veneerName}(settings);
    }

    /**
     * Constructs an instance of PublisherApi, using the given settings. This is protected so that it
     * easy to make a subclass, but otherwise, the static factory methods should be preferred.
     */
    protected {@veneerName}(ServiceApiSettings settings) throws IOException {
      ServiceApiSettings internalSettings = ApiUtils.populateSettings(settings,
          SERVICE_ADDRESS, DEFAULT_SERVICE_PORT, ALL_SCOPES);
      this.settings = internalSettings;
      this.channel = internalSettings.getChannel();
    }
  @end
@end

@private callables(service)
  // =============
  // Service Calls
  // =============

  @join method : service.getMethods
    @let callableConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
         methodName = context.upperCamelToLowerCamel(method.getSimpleName), \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         requestFactoryName = context.getRequestFactoryName(service), \
         isPageStreaming = context.getApiConfig.getMethodConfig(method).isPageStreaming, \
         isFlattening = context.getApiConfig.getMethodConfig(method).isFlattening
      // ----- {@methodName} -----

      # TODO (garrettjones) put some kind of limit on number of flattened parameters, and
      # don't generated a flattened method if there are too many.
      @if {@isPageStreaming}
        @if {@isFlattening}
          @join flatteningGroup: \
              context.getApiConfig.getMethodConfig(method).getFlattening().getFlatteningGroups()
            {@iterableFlattenedMethod(method, methodName, requestFactoryName, flatteningGroup)}
          @end
          {@BREAK}
        @end
        {@iterableMethodWithRequestParam(method, methodName, inTypeName, outTypeName)}
        {@methodReturningStreamingCallable(method, methodName, inTypeName, outTypeName)}
      @else
        @if {@isFlattening}
          @join flatteningGroup : \
              context.getApiConfig.getMethodConfig(method).getFlattening().getFlatteningGroups()
            {@flattenedMethod(method, methodName, requestFactoryName, flatteningGroup)}
          @end
          {@BREAK}
        @end
        {@methodWithRequestParam(method, methodName, inTypeName, outTypeName)}
      @end
      {@methodReturningCallable(method, callableConstant, methodName, inTypeName, outTypeName)}
    @end
  @end
@end

@private cleanupSection()
  // ========
  // Cleanup
  // ========

  /**
   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately
   * cancelled.
   */
  @@Override
  public void close() {
    // Manually-added shutdown code

    // Auto-generated shutdown code
    channel.shutdown();

    // Manually-added shutdown code
  }

@end

@private manualSection()
  // ========
  // Manually-added methods: add custom (non-generated) methods after this point.
  // ========

@end

@private iterableFlattenedMethod(method, methodName, requestFactoryName, fields)
  {@methodJavaDoc(method)}
  @let resourceTypeName = context.pageStreamingResourceType(method.getOutputType), \
       requestTypeName = context.typeName(method.getInputType)
    public Iterable<{@resourceTypeName}> \
        {@methodName}({@flattenedParameters(fields)}) {
      {@context.typeName(method.getInputType)} request =
          {@requestTypeName}.newBuilder()
          {@builderSetCalls(fields)}
          .build();
      return {@methodName}(request);
    }

  @end
@end

@private iterableMethodWithRequestParam(method, methodName, inTypeName, outTypeName)
  {@methodWithRequestParamJavaDoc(method)}
  @let resourceTypeName = context.pageStreamingResourceType(method.getOutputType),\
       dummy = context.addImport("io.gapi.gax.grpc.PageDescriptor")
    public Iterable<{@resourceTypeName}> {@methodName}({@inTypeName} request) {
      return {@methodName}StreamingCallable()
          .iterableResponseStreamCall(request);
    }

  @end
@end

@private methodReturningStreamingCallable(method, methodName, inTypeName, outTypeName)
  {@methodJavaDoc(method)}
  @let resourceTypeName = context.pageStreamingResourceType(method.getOutputType), \
       methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName)
    public ApiCallable<{@inTypeName}, {@resourceTypeName}> {@methodName}StreamingCallable() {
      return {@methodName}Callable().pageStreaming({@methodConstant}_PAGE_DESC);
    }

  @end
@end

@private flattenedMethod(method, methodName, requestFactoryName, fields)
  {@flattenedMethodJavaDoc(method, fields)}
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       returnStatement = context.methodReturnStatement(method.getOutputType), \
       requestTypeName = context.typeName(method.getInputType)
    public {@returnType} {@methodName}({@flattenedParameters(fields)}) {
      {@context.typeName(method.getInputType)} request =
          {@requestTypeName}.newBuilder()
          {@builderSetCalls(fields)}
          .build();

      {@returnStatement}{@methodName}(request);
    }

  @end
@end

@private methodWithRequestParam(method, methodName, inTypeName, outTypeName)
  {@methodWithRequestParamJavaDoc(method)}
  @let returnType = context.methodReturnTypeName(method.getOutputType), \
       returnStatement = context.methodReturnStatement(method.getOutputType)
    public {@returnType} {@methodName}({@inTypeName} request) {
      {@returnStatement}{@methodName}Callable().call(request);
    }

  @end
@end

@private methodReturningCallable(method, callableConstant, methodName, inTypeName, outTypeName)
  {@methodJavaDoc(method)}
  public ApiCallable<{@inTypeName}, {@outTypeName}> {@methodName}Callable() {
    @if context.resources.isIdempotent(method)
      return ApiUtils.prepareIdempotentCallable({@callableConstant}, settings).bind(channel);
    @else
      return {@callableConstant}.bind(channel);
    @end
  }

@end

@private serviceJavaDoc(protoElement)
  {@autoGenServiceWarning()}
  {@javaDoc(protoElement)}
@end

@private methodJavaDoc(protoElement)
  {@autoGenMethodWarning()}
  {@javaDoc(protoElement)}
@end

@private methodWithRequestParamJavaDoc(protoElement)
  {@autoGenMethodWarning()}
  {@javaDocStart()}
  {@javaDocLines(protoElement)}
  {@javaDocEmptyLine()}
  {@javaDocGenericRequestParam()}
  {@javaDocEnd()}
@end

@private flattenedMethodJavaDoc(method, fields)
  {@autoGenMethodWarning()}
  {@javaDocStart()}
  {@javaDocLines(method)}
  {@javaDocEmptyLine()}
  @join field : fields vertical
    @join commentLine : context.getJavaDocLinesWithPrefix(getDoc(field), paramDocLinePrefix(field))
      {@commentLine}
    @end
  @end
  {@javaDocEnd()}
@end

@private autoGenServiceWarning()
  // AUTO-GENERATED DOCUMENTATION AND SERVICE - see instructions at the top of the file for editing.
@end

@private autoGenMethodWarning()
  // AUTO-GENERATED DOCUMENTATION AND METHOD - see instructions at the top of the file for editing.
@end

@private paramDocLinePrefix(field)
  @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName), \
      lineBarrier = ""
    @@param {@paramName} {@lineBarrier}
  @end
@end

@private javaDoc(protoElement)
  {@javaDocStart()}
  {@javaDocLines(protoElement)}
  {@javaDocEnd()}
@end

@private javaDocLines(protoElement)
  @join commentLine : context.getJavaDocLines(getDoc(protoElement))
    {@commentLine}
  @end
@end

@private javaDocStart()
  /**
@end

@private javaDocEmptyLine()
  @let lineBarrier = ""
    {@lineBarrier} *
  @end
@end

@private javaDocGenericRequestParam()
  @let lineBarrier = ""
    {@lineBarrier} * @@param request The request object containing all \
        of the parameters for the API call.
  @end
@end

@private javaDocEnd()
  @let lineBarrier = ""
    {@lineBarrier} */
  @end
@end

@private getDoc(protoElement)
  {@context.getDescription(protoElement)}
@end

@private flattenedParameters(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@context.typeName(field.getType)} {@paramName}
    @end
  @end
@end

@private flattenedArguments(fields)
  @join field : fields on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@paramName}
    @end
  @end
@end

@private builderSetCalls(fields)
  @join field : fields
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      .{@setCallName(field)}({@paramName})
    @end
  @end
@end

@private setCallName(field)
  @let paramNameInCamel = context.lowerUnderscoreToUpperCamel(field.getSimpleName)
    @if field.isRepeated
      addAll{@paramNameInCamel}
    @else
      set{@paramNameInCamel}
    @end
  @end
@end

@private getCallName(field)
  @let paramNameInCamel = context.lowerUnderscoreToUpperCamel(field.getSimpleName)
    @if field.isRepeated
      get{@paramNameInCamel}List
    @else
      get{@paramNameInCamel}
    @end
  @end
@end
