@snippet generateFilename(service)
  {@context.getRequestFactoryName(service)}.java
@end

@snippet generateClass(service, body, imports)
  /*
   * Copyright 2015, Google Inc. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *    * Redistributions of source code must retain the above copyright
   * notice, this list of conditions and the following disclaimer.
   *    * Redistributions in binary form must reproduce the above
   * copyright notice, this list of conditions and the following disclaimer
   * in the documentation and/or other materials provided with the
   * distribution.
   *
   *    * Neither the name of Google Inc. nor the names of its
   * contributors may be used to endorse or promote products derived from
   * this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  /*
   * EDITING INSTRUCTIONS
   * This file was generated from the file {@service.getFile.getLocation.getDisplayString},
   * and updates to that file get reflected here through a regular refresh process.
   * However, manual additions are allowed because the refresh process performs
   * a 3-way merge in order to preserve those manual additions. In order to not
   * break the refresh process, only certain types of modifications are
   * allowed.
   *
   * Allowed modifications - currently there is only one type allowed:
   * 1. New methods (these should be added to the end of the class)
   *
   * Happy editing!
   */
  package {@context.getJavaPackage(service.getFile)};

  @join import : imports
    import {@import};
  @end

  // Manually-added imports: add custom (non-generated) imports after this point.

  {@body}
@end

@snippet generateBody(service)
  {@alwaysImport()}

  /**
   * A utility class with methods to construct request objects for making service calls
   * using {@context.getVeneerName(service)}.
   */
  @@javax.annotation.Generated("by the veneer generator")
  public class {@context.getRequestFactoryName(service)} {

    @join fieldSegment : context.resources.getFieldSegmentsFromHttpPaths(service.getMethods)
      {@pathTemplateConstant(fieldSegment)}
    @end

    @join fieldSegment : context.resources.getFieldSegmentsFromHttpPaths(service.getMethods)
      {@createResourceFunction(fieldSegment)}
    @end

    @join method : service.getMethods
      {@createRequestMethod(method)}
    @end

    // ========
    // Manually-added methods: add custom (non-generated) methods after this point.
    // ========

  }
@end

@private alwaysImport() fill
  {@context.addImport("io.gapi.gax.protobuf.PathTemplate")}
@end

@private pathTemplateConstant(fieldSegment)
  public static final PathTemplate {@pathTemplateConstantName(fieldSegment)} =
      PathTemplate.create("{@context.resources.templatize(fieldSegment)}");
@end

@private pathTemplateConstantName(fieldSegment)
  {@context.lowerUnderscoreToUpperUnderscore(fieldSegment.getFieldPath)}_PATH_TEMPLATE
@end


@private createResourceFunction(fieldSegment)
  public static final String {@createResourceFunctionName(fieldSegment)}(\
      {@createResourceFunctionParams(fieldSegment)}) {
    return {@pathTemplateConstantName(fieldSegment)}.instantiate(
        {@pathTemplateArgs(fieldSegment)});
  }

@end
@private createResourceFunctionName(fieldSegment)
  create{@context.lowerUnderscoreToUpperCamel(fieldSegment.getFieldPath)}
@end

@private createResourceFunctionParams(fieldSegment)
  @join param : context.resources.getParamsForResourceNameWildcards(fieldSegment) on ", "
    String {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private pathTemplateArgs(fieldSegment)
  @join param : context.resources.getParamsForResourceNameWildcards(fieldSegment) vertical on ","
    "{@param}", {@context.lowerUnderscoreToLowerCamel(param)}
  @end
@end

@private createRequestMethod(method)
  @let returnTypeName = {@context.typeName(method.getInputType)}
    public static {@returnTypeName} {@requestMethodName(method)}\
        ({@flattenedParameters(method.getInputType)}) {
      return {@returnTypeName}.newBuilder()
          {@builderSetCalls(method.getInputType)}
          .build();
    }

  @end
@end

@private requestMethodName(method)
  {@context.upperCamelToLowerCamel(context.typeName(method.getInputType))}
@end

# Duplicated from main.snip
@private flattenedParameters(inType)
  @join field : context.messages.flattenedFields(inType) on ", "
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      {@context.typeName(field.getType)} {@paramName}
    @end
  @end
@end

@private builderSetCalls(inType)
  @join field : context.messages.flattenedFields(inType)
    @let paramName = context.lowerUnderscoreToLowerCamel(field.getSimpleName)
      .{@setCallName(field)}({@paramName})
    @end
  @end
@end

@private setCallName(field)
  @let paramNameInCamel = context.lowerUnderscoreToUpperCamel(field.getSimpleName)
    @if field.isRepeated
      addAll{@paramNameInCamel}
    @else
      set{@paramNameInCamel}
    @end
  @end
@end
