@extends "common.snip"

@snippet generateFilename(service)
  {@settingsClassName(service)}.java
@end

@snippet generateClass(service, body, imports)
  {@fileHeader(service)}
  package {@context.getApiConfig.getPackageName};

  @join import : imports
    import {@import};
  @end

  // Manually-added imports: add custom (non-generated) imports after this point.

  {@body}
@end

@snippet generateBody(service)
  {@alwaysImport()}

  {@autoGenClassWarning()}
  @@javax.annotation.Generated("by GAPIC")
  public class {@settingsClassName(service)} extends ServiceApiSettings {

    {@constants(service)}

    {@members(service)}

    {@methodBuildersInnerClass(service)}

    {@constructors(service)}

    {@memberFunctions(service)}

    {@descriptors(service)}
  }
@end

@private alwaysImport() fill
  {@context.addImport("com.google.api.gax.core.BackoffParams")}
  {@context.addImport("com.google.api.gax.core.ConnectionSettings")}
  {@context.addImport("com.google.api.gax.core.RetryParams")}
  {@context.addImport("com.google.api.gax.grpc.ApiCallSettings")}
  {@context.addImport("com.google.api.gax.grpc.ApiCallable")}
  {@context.addImport("com.google.api.gax.grpc.ApiCallable.Builder")}
  {@context.addImport("com.google.api.gax.grpc.ServiceApiSettings")}
  {@context.addImport("com.google.common.collect.ImmutableList")}
  {@context.addImport("com.google.common.collect.ImmutableMap")}
  {@context.addImport("com.google.common.collect.ImmutableSet")}
  {@context.addImport("com.google.common.collect.Lists")}
  {@context.addImport("com.google.common.collect.Sets")}
  {@context.addImport("io.grpc.Status")}
  {@context.addImport("org.joda.time.Duration")}
@end

@private constants(service)
  {@connectionConstants(service)}
  {@retryDefConstants(service)}
@end

@private connectionConstants(service)
  /**
   * The default address of the service.
   *
  {@javaDocManualEdit()}
   */
  public static final String DEFAULT_SERVICE_ADDRESS = "{@context.getServiceConfig.getServiceAddress(service)}";

  /**
   * The default port of the service.
   *
  {@javaDocManualEdit()}
   */
  public static final int DEFAULT_SERVICE_PORT = {@context.getServiceConfig.getServicePort()};

  /**
   * The default scopes of the service.
   */
  public static final ImmutableList<String> DEFAULT_SERVICE_SCOPES = ImmutableList.<String>builder()
      @join scope : context.getServiceConfig.getAuthScopes(service)
        .add("{@scope}")
      @end
      .build();

@end

@private retryDefConstants(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service)
    private static final ImmutableMap<String, ImmutableSet<Status.Code>> RETRYABLE_CODE_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, ImmutableSet<Status.Code>> definitions = ImmutableMap.builder();
      @join retryDef : context.entrySet(interfaceConfig.getRetryCodesDefinition)
        definitions.put(
            "{@retryDef.getKey}",
            Sets.immutableEnumSet(Lists.<Status.Code>newArrayList({@statusCodes(retryDef.getValue)})));
      @end
      RETRYABLE_CODE_DEFINITIONS = definitions.build();
    }

    private static final ImmutableMap<String, RetryParams> RETRY_PARAM_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, RetryParams> definitions = ImmutableMap.builder();
      RetryParams params = null;
      @join retryDef : context.entrySet(interfaceConfig.getRetryParamsDefinition)
        params = RetryParams.newBuilder()
            .setInitialRetryDelay(Duration.millis({@retryDef.getValue.getInitialRetryDelay.getMillis}L))
            .setRetryDelayMultiplier({@retryDef.getValue.getRetryDelayMultiplier})
            .setMaxRetryDelay(Duration.millis({@retryDef.getValue.getMaxRetryDelay.getMillis}L))
            .setInitialRpcTimeout(Duration.millis({@retryDef.getValue.getInitialRpcTimeout.getMillis}L))
            .setRpcTimeoutMultiplier({@retryDef.getValue.getRpcTimeoutMultiplier})
            .setMaxRpcTimeout(Duration.millis({@retryDef.getValue.getMaxRpcTimeout.getMillis}L))
            .setTotalTimeout(Duration.millis({@retryDef.getValue.getTotalTimeout.getMillis}L))
            .build();
        definitions.put("{@retryDef.getKey}", params);
      @end
      RETRY_PARAM_DEFINITIONS = definitions.build();
    }
  @end
@end

@private statusCodes(codes)
  @join code : codes on ", "
    Status.Code.{@code}
  @end
@end

@private methodBuildersInnerClass(service)
  private static class MethodBuilders {
    {@methodBuildersMembers(service)}

    {@methodBuildersConstructor(service)}
  }
@end

@private methodBuildersMembers(service)
  @join method : service.getMethods
    @let methodName = context.upperCamelToLowerCamel(method.getSimpleName), \
         methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         isPageStreaming = methodConfig.isPageStreaming, \
         isBundling = methodConfig.isBundling
      @if {@isPageStreaming}
        @let pageStreaming = methodConfig.getPageStreaming(), \
             resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
             dummy = context.addImport("com.google.api.gax.grpc.ApiCallable.PageStreamingBuilder")
          private final ApiCallable.PageStreamingBuilder<{@inTypeName}, {@outTypeName}, {@resourceTypeName}>
              {@methodName}Method;
        @end
      @else
        @if {@isBundling}
          @let bundling = methodConfig.getBundling(), \
               dummy = context.addImport("com.google.api.gax.grpc.ApiCallable.BundlableBuilder")
            private final ApiCallable.BundlableBuilder<{@inTypeName}, {@outTypeName}> {@methodName}Method;
          @end
        @else
          private final ApiCallable.Builder<{@inTypeName}, {@outTypeName}> {@methodName}Method;
        @end
      @end
    @end
  @end

  private final ImmutableList<? extends ApiCallSettings> allMethods;
@end

@private methodBuildersConstructor(service)
  public MethodBuilders() {
    @let serviceName = service.getSimpleName, \
         grpcName = context.getGrpcName(service)
      @join method : service.getMethods
        @let methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
             methodName = context.upperCamelToLowerCamel(method.getSimpleName), \
             methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             retryCodesName = methodConfig.getRetryCodesConfigName, \
             retryParamsName = methodConfig.getRetryParamsConfigName, \
             isPageStreaming = methodConfig.isPageStreaming, \
             isBundling = methodConfig.isBundling
          @if {@isPageStreaming}
            {@methodName}Method = new PageStreamingBuilder<>(
                {@grpcName}.METHOD_{@methodConstant},
                {@methodConstant}_PAGE_STR_DESC);
          @else
            @if {@isBundling}
              @let bundlingConfig = methodConfig.getBundling, \
                   dummy = {@context.addImport("com.google.api.gax.grpc.BundlingSettings")}
                BundlingSettings {@methodName}BundlingSettings =
                    BundlingSettings.newBuilder()
                        .setElementCountThreshold({@bundlingConfig.getElementCountThreshold})
                        .setElementCountLimit({@bundlingConfig.getElementCountLimit})
                        .setRequestByteThreshold({@bundlingConfig.getRequestByteThreshold})
                        .setRequestByteLimit({@bundlingConfig.getRequestByteLimit})
                        .setDelayThreshold(Duration.millis({@bundlingConfig.getDelayThresholdMillis}))
                        .setBlockingCallCountThreshold(1)
                        .build();
                {@methodName}Method = new BundlableBuilder<>(
                    {@grpcName}.METHOD_{@methodConstant},
                    {@methodConstant}_BUNDLING_DESC,
                    {@methodName}BundlingSettings);
              @end
            @else
              {@methodName}Method = new Builder<>({@grpcName}.METHOD_{@methodConstant});
            @end
          @end

          {@methodName}Method.setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("{@retryCodesName}"));
          {@methodName}Method.setRetryParams(RETRY_PARAM_DEFINITIONS.get("{@retryParamsName}"));

        @end
      @end

      allMethods =
          ImmutableList.<ApiCallSettings>builder()
              .add(
                  {@methodList(service)}
              ).build();
    @end
  }
@end

@private members(service)
  private final MethodBuilders methods;

@end

@private constructors(service)
  @let className = @settingsClassName(service)
    /**
     * Constructs an instance of {@className} with default settings.
     *
    {@javaDocManualEdit()}
     */
    public static {@className} create() {
      {@className} settings = new {@className}(new MethodBuilders());
      settings.provideChannelWith(ConnectionSettings.builder()
          .setServiceAddress(DEFAULT_SERVICE_ADDRESS)
          .setPort(DEFAULT_SERVICE_PORT)
          .provideCredentialsWith(DEFAULT_SERVICE_SCOPES)
          .build());
      return settings;
    }

    /**
     * Constructs an instance of {@className} with default settings. This is protected
     * so that it easy to make a subclass, but otherwise, the static factory methods should be
     * preferred.
     *
    {@javaDocManualEdit()}
     */
    protected {@className}(MethodBuilders methods) {
      super(methods.allMethods);
      this.methods = methods;
    }
  @end
@end

@private methodList(service)
  @join method : service.getMethods on ","
{@context.upperCamelToLowerCamel(method.getSimpleName)}Method
  @end
@end

@private memberFunctions(service)
  @join method : service.getMethods
    @let methodName = context.upperCamelToLowerCamel(method.getSimpleName), \
         methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
         inTypeName = context.typeName(method.getInputType), \
         outTypeName = context.typeName(method.getOutputType), \
         isPageStreaming = methodConfig.isPageStreaming, \
         isBundling = methodConfig.isBundling
      /**
       * Returns the builder for the API method {@methodName}.
       *
      {@javaDocManualEdit()}
       */
      @if {@isPageStreaming}
        @let pageStreaming = methodConfig.getPageStreaming(), \
             resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType())
          public final ApiCallable.PageStreamingBuilder<{@inTypeName}, {@outTypeName}, {@resourceTypeName}>
              {@methodName}Method() {
            return methods.{@methodName}Method;
          }
        @end
      @else
        @if {@isBundling}
          public final ApiCallable.BundlableBuilder<{@inTypeName}, {@outTypeName}> {@methodName}Method() {
            return methods.{@methodName}Method;
          }
        @else
          public final ApiCallable.Builder<{@inTypeName}, {@outTypeName}> {@methodName}Method() {
            return methods.{@methodName}Method;
          }
        @end
      @end

    @end
  @end

@end

@private descriptors(service)
  {@pageStreamingDescriptors(service)}
  {@bundlingDescriptors(service)}
@end

@private pageStreamingDescriptors(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service), \
       dummy = context.addImport("com.google.api.gax.grpc.PageStreamingDescriptor")
    @join method : context.messages.filterPageStreamingMethods(interfaceConfig, service.getMethods)
      @let methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType), \
           pageStreaming = interfaceConfig.getMethodConfig(method).getPageStreaming(), \
           resourceTypeName = context.basicTypeNameBoxed(pageStreaming.getResourcesField().getType()), \
           tokenTypeName = context.typeName(pageStreaming.getResponseTokenField.getType)
        private static PageStreamingDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}> {@methodConstant}_PAGE_STR_DESC =
            new PageStreamingDescriptor<{@inTypeName}, {@outTypeName}, {@resourceTypeName}>() {
              @@Override
              public Object emptyToken() {
                return {@context.defaultTokenValue(pageStreaming.getRequestTokenField())};
              }
              @@Override
              public {@inTypeName} injectToken(
                  {@inTypeName} payload, Object token) {
                return {@inTypeName}
                  .newBuilder(payload)
                  .{@setCallName(pageStreaming.getRequestTokenField())}(({@tokenTypeName}) token)
                  .build();
              }
              @@Override
              public Object extractNextToken({@outTypeName} payload) {
                return payload.{@getCallName(pageStreaming.getResponseTokenField())}();
              }
              @@Override
              public Iterable<{@resourceTypeName}> extractResources({@outTypeName} payload) {
                return payload.{@getCallName(pageStreaming.getResourcesField())}();
              }
            };

      @end
    @end
  @end
@end

@private bundlingDescriptors(service)
  @let interfaceConfig = context.getApiConfig.getInterfaceConfig(service)
    @join method : context.messages.filterBundlingMethods(interfaceConfig, service.getMethods)
      @let methodConstant = context.upperCamelToUpperUnderscore(method.getSimpleName), \
           inTypeName = context.typeName(method.getInputType), \
           outTypeName = context.typeName(method.getOutputType), \
           bundling = interfaceConfig.getMethodConfig(method).getBundling(), \
           dummy = context.addImport("com.google.api.gax.grpc.BundlingDescriptor"), \
           dummy2 = context.addImport("java.util.Collection"), \
           dummy3 = context.addImport("com.google.api.gax.grpc.RequestIssuer"), \
           dummy4 = context.addImport("java.util.ArrayList")
        private static BundlingDescriptor<{@inTypeName}, {@outTypeName}> {@methodConstant}_BUNDLING_DESC =
            new BundlingDescriptor<{@inTypeName}, {@outTypeName}>() {
              @@Override
              public String getBundlePartitionKey({@inTypeName} request) {
                return {@partitionKeyCode(bundling)};
              }

              @@Override
              public {@inTypeName} mergeRequests(Collection<{@inTypeName}> requests) {
                {@inTypeName} firstRequest = requests.iterator().next();

                {@context.typeName(bundling.getBundledField.getType)} elements = new ArrayList<>();
                for ({@inTypeName} request : requests) {
                  elements.addAll(request.{@getCallName(bundling.getBundledField)}());
                }

                {@inTypeName} bundleRequest =
                    {@inTypeName}.newBuilder()
                        {@setDescriminatorFields(bundling)}
                        .{@setCallName(bundling.getBundledField)}(elements)
                        .build();
                return bundleRequest;
              }

              @@Override
              public void splitResponse(
                  {@outTypeName} bundleResponse,
                  Collection<? extends RequestIssuer<{@inTypeName}, {@outTypeName}>> bundle) {
                # TODO(garrettjones) support case of no subresponse_field (e.g. Logging)
                int bundleMessageIndex = 0;
                for (RequestIssuer<{@inTypeName}, {@outTypeName}> responder : bundle) {
                  {@context.typeName(bundling.getSubresponseField.getType)} subresponseElements = new ArrayList<>();
                  int subresponseCount = responder.getRequest().{@getCountCallName(bundling.getBundledField)}();
                  for (int i = 0; i < subresponseCount; i++) {
                    subresponseElements.add(bundleResponse.{@getIndexCallName(bundling.getSubresponseField)}(bundleMessageIndex));
                    bundleMessageIndex += 1;
                  }
                  {@outTypeName} response =
                      {@outTypeName}.newBuilder().{@setCallName(bundling.getSubresponseField)}(subresponseElements).build();
                  responder.setResponse(response);
                }
              }

              @@Override
              public void splitException(
                  Throwable throwable,
                  Collection<? extends RequestIssuer<{@inTypeName}, {@outTypeName}>> bundle) {
                for (RequestIssuer<{@inTypeName}, {@outTypeName}> responder : bundle) {
                  responder.setException(throwable);
                }
              }

              @@Override
              public long countElements({@inTypeName} request) {
                return request.{@getCountCallName(bundling.getBundledField)}();
              }

              @@Override
              public long countBytes({@inTypeName} request) {
                return request.getSerializedSize();
              }
            };

      @end
    @end
  @end
@end

@private partitionKeyCode(bundling)
  {@context.partitionKeyCode(bundling.getDiscriminatorFields)}
@end

@private setDescriminatorFields(bundling)
  @join fieldSelector : bundling.getDiscriminatorFields
    # Note: This only supports field selectors with a single field.
    @let field = fieldSelector.getLastField
      .{@setCallName(field)}(firstRequest.{@getCallName(field)}())
    @end
  @end
@end

@snippet generateMethodSampleCode(sampleConfig)
# not used
@end
